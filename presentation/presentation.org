#    -*- mode: org -*-
#+OPTIONS: reveal_center:t reveal_progress:t reveal_history:t reveal_control:nil
#+OPTIONS: reveal_mathjax:t reveal_rolling_links:nil reveal_keyboard:t reveal_overview:t num:nil
#+OPTIONS: reveal_width:1200 reveal_height:900
#+OPTIONS: toc:nil <:nil timestamp:nil email:t reveal_slide_number:"c/t"
#+REVEAL_MARGIN: 0.1
#+REVEAL_MIN_SCALE: 0.5
#+REVEAL_MAX_SCALE: 2.5
#+REVEAL_TRANS: slide
#+REVEAL_THEME: solarized
#+REVEAL_HLEVEL: 2
#+REVEAL_EXTRA_CSS: ./presentation.css
#+REVEAL_ROOT: ../../presentations/reveal.js/

# (setq org-reveal-title-slide "<h1>%t</h1><h2>Exploring an Algorithmic Empire</h2><br/><h2>%a</h2><h3>%e / <a href=\"http://twitter.com/ben_deane\">@ben_deane</a></h3><h2>%d</h2>")
# (setq org-reveal-title-slide 'auto)
# see https://github.com/yjwen/org-reveal/commit/84a445ce48e996182fde6909558824e154b76985

#+TITLE: std::accumulate
#+AUTHOR: Ben Deane
#+EMAIL: bdeane@blizzard.com
#+DATE: Sometime 2016

* Part 0: The Most Powerful Algorithm in the World?

** A Long Time Ago, In a Galaxy etc...
[[./powerful.png]]

** A Long Time Ago, In a Galaxy etc...
[[./another_talk.png]]

** Nomenclature note
I'll try to talk "in C++" for this talk.

But I may occasionally say "fold" when I mean "accumulate" or "reduce".

Don't worry... this talk isn't FP-heavy.

* Part 1: Accumulatable Things

** ~std::accumulate~
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
template <class InputIt, class T, class BinaryOp>
T accumulate(InputIt first, InputIt last,
             T init, BinaryOp op)
{
  for (; first != last; ++first) {
    init = op(init, *first);
  }
  return init;
}
#+END_SRC

** Typical uses
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
vector<int> v = {1,2,3,4,5};

int sum = accumulate(v.cbegin(), v.cend(), 0, plus<>{});
cout << sum << '\n';

int product = accumulate(v.cbegin(), v.cend(), 1, multiplies<>{});
cout << product << '\n';
#+END_SRC
#+REVEAL_HTML: <br/>
#+ATTR_REVEAL: :frag appear
Of course, this is not why you're here.
What else can we accumulate?

** How about finding a min or max?
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
vector<unsigned> v = {1,2,3,4,5};

unsigned max_val = accumulate(v.cbegin(), v.cend(), 0,
    [] (unsigned a, unsigned b) { return a > b ? a : b; });
cout << max_val << '\n';
#+END_SRC

** How about finding a min or max?
Value-based ~min_element~ or ~max_element~
#+BEGIN_SRC cpp
template <typename It, typename Compare,
          typename T = typename std::iterator_traits<It>::value_type>
T min_element(It first, It last, Compare cmp)
{
  // precondition: first != last
  auto init = *first;
  return accumulate(
      ++first, last, init,
      [&] (const T& a, const T& b) {
        return cmp(b, a) ? b : a;
      });
}
#+END_SRC

** What about ~bool~ values?
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
bool results[] = {true, false, true, true, false};

bool all_true = accumulate(cbegin(results), cend(results),
                           true, logical_and<>{});
bool some_true = accumulate(cbegin(results), cend(results),
                            false, logical_or<>{});
bool none_true = !accumulate(cbegin(results), cend(results),
                             false, logical_or<>{});
#+END_SRC
#+REVEAL_HTML: <br/>
#+ATTR_REVEAL: :frag appear
Not that interesting yet...

** The signature of the function
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
Ret fun(const Type1 &a, const Type2 &b);
#+END_SRC
#+ATTR_REVEAL: :frag appear
So far, we've looked at ~Type1~ and ~Type2~ being the same.
#+ATTR_REVEAL: :frag appear
Things get more interesting when they differ.

** A more interesting ~bool~ case
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
map<int, weak_ptr<thing>> cache;

shared_ptr<thing> get_thing(int id) {
  auto sp = cache[id].lock();
  if (!sp) make_async_request(id);
  return sp;
}

void load_things(const vector<int>& ids)
{
  bool all_cached = accumulate(
    ids.cbegin(), ids.cend(), true,
    [] (bool cached, int id) {
      return get_thing(id) && cached;
    });
  if (!all_cached)
    service_async_requests();
}
#+END_SRC

** ~bool~ As the Result
We use many function results as boolean values in control flow.
 - actual ~bool~
 - pointers
 - zero-result of a comparison trichotomy
 - anywhere else we want to write ~if (x)~

#+ATTR_REVEAL: :frag appear
This means we can use ~accumulate~ to collect these function values. (Similar to
~all_of~, ~any_of~, ~none_of~, but where we don't want the short-circuiting
behavior.)

** More things...
 - joining strings
 - building requests from key-value pairs
 - merging JSON objects
 - composing textures

#+ATTR_REVEAL: :frag appear
What do all of these have in common?

** You All Remember Monoids?
A set of objects and an operation such that:
 - The operation is closed over the set
 - The operation is associative
 - There is an identity element

#+ATTR_REVEAL: :frag appear
Monoids are everywhere, and any monoid can be accumulated:
#+ATTR_REVEAL: :frag (appear)
 - addition on integers
 - concatenation on strings
 - union on sets
 - composition of textures

** Building HTTP headers: Before
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
curl_slist* curl_headers = NULL;
for (auto it = headers.begin();
     it != headers.end(); ++it)
{
  curl_headers = curl_slist_append(curl_headers,
    (format("%s: %s") % it->first % it->second).str().c_str());
}
#+END_SRC

** Building HTTP headers: After
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
curl_slist* curl_headers = accumulate(
    headers.cbegin(), headers.cend(), static_cast<curl_slist*>(nullptr),
    [] (curl_slist* h, const auto& v) {
        return curl_slist_append(h,
          (format("%s: %s") % it->first % it->second).str().c_str());
      });
#+END_SRC

** More Monoid Observations
#+ATTR_REVEAL: :frag appear
A type can be a monoid in more than one way (under more than one operation).
#+ATTR_REVEAL: :frag appear
A function that returns a monoid is a monoid.
#+ATTR_REVEAL: :frag appear
An aggregate of monoids is a monoid.

** Why not just write a loop?
Some advantages to ~accumulate~

#+ATTR_REVEAL: :frag (appear)
 - No declaration/initialization split
 - It's often easier to write a binary function
   - or unary function with monoidal output
 - Incremental computation
 - Potential for parallel computation

** What ~accumulate~ Can Do
#+ATTR_REVEAL: :frag (appear)
 - Turn binary functions into n-ary functions
 - Collect results of functions whose outputs are monoidal
 - Transform one data structure into another
 - Allow part-whole hierarchies to be treated uniformly
   - which unlocks parallel computation

* Part 2: Parallel Computation

** Distributed Accumulate
[[./distributed_add.svg]]

** Distributed Accumulate
[[./distributed_average.svg]]

** ~std::reduce~
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
template <class InputIt, class T, class BinaryOp>
T reduce(InputIt first, InputIt last,
         T init, BinaryOp op);
#+END_SRC
#+ATTR_REVEAL: :frag appear
The same as ~accumulate~, except the collection may be processed in parallel.
#+ATTR_REVEAL: :frag appear
This works because of associativity (semigroup property).
#+ATTR_REVEAL: :frag appear
We lose the type variation, but gain parallelism.

** Big Data Monoids Everywhere
#+ATTR_REVEAL: :frag (appear)
 - histograms
 - top-N calculations
 - computing averages
 - gaussian distributions
 - bloom filters
 - count-min sketch
 - hyperloglog

* Part 3: Nonlinear Structures

** ~accumulate~ Works on Linear Sequences
How would we make it work on multi-dimensional structures?
#+ATTR_REVEAL: :frag appear
Maybe we can define a linear traversal on the structure (in-order, pre-order,
post-order)...
#+ATTR_REVEAL: :frag appear
But the nodes are still homogeneous...
#+ATTR_REVEAL: :frag appear
What if it's a bit more complex? (Like say, a JSON object?)

** Recall ~std::accumulate~
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
template <class InputIt, class T, class BinaryOp>
T accumulate(InputIt first, InputIt last,
             T init, BinaryOp op);
#+END_SRC

The ~T~ here deals with an empty sequence.

The ~BinaryOp~ deals with a non-empty sequence.

** Recursive Definition of a ~vector~
We can view "sequence accumulation" as handling two cases:
 - an empty ~vector~
 - a ~vector~ consisting of an element plus another ~vector~

This is the sort of recursive definition we find in functional languages. And
it's the key to accumulating other data structures.

** ~std::accumulate~ Viewed Recursively
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
template <typename FwdIt, typename EmptyOp, typename NonEmptyOp>
auto recursive_accumulate(FwdIt first, FwdIt last,
                          EmptyOp op1, NonEmptyOp op2)
{
  if (first == last) return op1();
  return op2(*first, recursive_accumulate(first+1, last, op1, op2));
}
#+END_SRC
#+ATTR_REVEAL: :frag appear
~T~ (here ~EmptyOp~) is really a function from empty ~vector~ to ~T~
#+ATTR_REVEAL: :frag appear
~BinaryOp~ (here ~NonEmptyOp~) is really a function from (element, ~vector~) to
~T~

** Accumulating a ~variant~
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
struct JSONWrapper;
using JSONArray = vector<JSONWrapper>;
using JSONObject = map<string, JSONWrapper>;
using JSONValue = variant<bool,
                          double,
                          string,
                          nullptr_t,
                          JSONArray,
                          JSONObject>;
struct JSONWrapper
{
  JSONValue v;
  operator JSONValue&() { return v; }
  operator const JSONValue&() const { return v; }
};
#+END_SRC

** Example: Render a ~JSONValue~ as a ~string~
We need a function for each distinct type that can be inside the ~variant~.
#+BEGIN_SRC cpp
string render_json_value(const JSONValue& jsv);

string render_bool(bool b) { return b ? "true" : "false"; };
string render_double(double d) { return to_string(d); };
string render_string(const string& s)
{
  stringstream ss;
  ss << quoted(s);
  return ss.str();
}
string render_null(nullptr_t) { return "null"; }
#+END_SRC

** Example: Render a ~JSONValue~ as a ~string~
We need a function for each distinct type that can be inside the ~variant~.
#+BEGIN_SRC cpp
string render_array(const JSONArray& a)
{
  return string{"["}
    + join(a.cbegin(), a.cend(), string{","},
           [] (const JSONValue& jsv) {
             return render_json_value(jsv);
           })
    + "]";
}
#+END_SRC

** Example: Render a ~JSONValue~ as a ~string~
We need a function for each distinct type that can be inside the ~variant~.
#+BEGIN_SRC cpp
string render_object(const JSONObject& o)
{
  return string{"{"}
    + join(o.cbegin(), o.cend(), string{","},
           [] (const JSONObject::value_type& jsv) {
             return render_string(jsv.first) + ":"
               + render_json_value(jsv.second);
           })
    + "}";
}
#+END_SRC

** Example: Render a ~JSONValue~ as a ~string~
We need a function for each distinct type that can be inside the ~variant~.
#+BEGIN_SRC cpp
string render_json_value(const JSONValue& jsv)
{
  return fold(jsv,
              render_bool, render_double, render_string,
              render_null, render_array, render_object);
}
#+END_SRC

** A Generic ~fold~ for ~variant~
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
template <typename... Ts, typename... Fs>
auto fold(const variant<Ts...>& v, Fs&&... fs)
{
  static_assert(sizeof...(Ts) == sizeof...(Fs),
                "Not enough functions provided to variant fold");
  return fold_at<0, sizeof...(Ts)>::apply(
      v, v.index(),
      std::forward<Fs>(fs)...);
}
#+END_SRC
A ~variant~, and N functions (one for each case of the ~variant~).

Recall that the "zero value" is implicit in the functions if required.

** A Generic ~fold~ for ~variant~
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
template <typename T, typename F, typename... Fs>
static auto fold_at(T&& t, size_t n, F&& f, Fs&&... fs)
{
  using R = decltype(f(get<0>(t)));
  return apply_at<0, sizeof...(Fs)+1>::template apply<R, T, F, Fs...>(
      std::forward<T>(t),
      n,
      std::forward<F>(f),
      std::forward<Fs>(fs)...);
}
#+END_SRC

** A Generic ~fold~ for ~variant~
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
template <size_t N, size_t Max>
struct apply_at
{
  template <typename R, typename T, typename F, typename... Fs>
  static auto apply(T&& t, size_t n, F&& f, Fs&&... fs)
  {
    if (n == N)
      return std::forward<F>(f)(get<N>(std::forward<T>(t)));
    else
      return apply_at<N+1, Max>::template apply<R, T, Fs...>(
          std::forward<T>(t),
          n,
          std::forward<Fs>(fs)...);
  }
};
#+END_SRC

** A Generic ~fold~ for ~variant~
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
template <size_t Max>
struct apply_at<Max, Max>
{
  template <typename R, typename T, typename... Fs>
  static auto apply(T, size_t, Fs...)
  {
    assert("Variant index out of range" && false);
    return R{};
  }
};
#+END_SRC

** Generic ~variant~ accumulation
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
template <typename... Ts, typename... Fs>
auto fold(const variant<Ts...>& v, Fs&&... fs)
#+END_SRC
Hmm, this looks a lot like visitation.

** Recursive reduction
Any recursively-specified data structure can be accumulated using visitation to
produce a monoidal value which is accumulated
#+ATTR_REVEAL: :frag (appear)
 - tree -> string rendering
 - depth, fringe of trees
 - lighting contributions
 - frustum culling

** Balanced reduction
TODO

* Part 4: Heterogeneous Sequences

** Foldads
TODO

* Part 5: The Opposite of Accumulate?

** Fold? Unfold
If ~accumulate~ is folding up a data structure to produce a value...
#+ATTR_REVEAL: :frag appear
The opposite is "unfolding" a seed value to produce a data structure.

** How To Unfold
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
template <typename InputIt, typename T, typename F>
T accumulate(InputIt first, InputIt last, T init, F f);

template <typename FwdIt, typename T, typename F>
FwdIt unfold(F f, FwdIt it, T init);
#+END_SRC
~F~ will be repeatedly called with a "reducing" ~T~ value and write the result(s)
to ~it~.

#+ATTR_REVEAL: :frag (appear)
 - What should the signature of F be?
 - How do we know when we're done?

** Signature of the Function Passed to ~unfold~
F is the opposite of ~accumulate~'s BinaryOp

#+ATTR_REVEAL: :frag appear
It's clear that ~F~ needs to return a ~pair~
#+ATTR_REVEAL: :frag (appear)
 * result to write into the iterator
 * new value of ~T~ to feed into next invocation of ~F~

#+ATTR_REVEAL: :frag appear
In general the "result to write to the iterator" may be a range or sequence of
values.

** Three Choices for ~unfold~ Termination
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
// 1. provide a sentinel value of type T
template <typename FwdIt, typename T, typename F>
FwdIt unfold(F f, FwdIt it, T init, T term);
#+END_SRC

** Three Choices for ~unfold~ Termination
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
// 2. provide a sentinel value of type (other thing returned by F)
template <typename FwdIt, typename T, typename F, typename U>
FwdIt unfold(F f, FwdIt it, T init, U term);
#+END_SRC

** Three Choices for ~unfold~ Termination
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
// 3. F will return an optional
template <typename FwdIt, typename T, typename F>
FwdIt unfold(F f, FwdIt it, T init);
#+END_SRC

** How To Unfold
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
template <typename FwdIt, typename T, typename F>
FwdIt unfold(F f, FwdIt it, T init)
{
  T t{std::forward<T>(init)};
  for (auto o = f(t); o; o = f(o->second)) {
    it = std::move(std::begin(o->first), std::end(o->first), it);
  }
  return it;
}
#+END_SRC
~F~ returns ~optional<pair<range, T>>~

** Unfold Example
#+BEGIN_SRC cpp -n
optional<pair<string, int>> to_roman(int n)
{
  if (n >= 1000) return {{ "M", n-1000 }};
  if (n >= 900) return {{ "CM", n-900 }};
  if (n >= 500) return {{ "D", n-500 }};
  if (n >= 400) return {{ "CD", n-400 }};
  if (n >= 100) return {{ "C", n-100 }};
  if (n >= 90) return {{ "XC", n-90 }};
  if (n >= 50) return {{ "L", n-50 }};
  if (n >= 40) return {{ "XL", n-40 }};
  if (n >= 10) return {{ "X", n-10 }};
  if (n >= 9) return {{ "IX", n-9 }};
  if (n >= 5) return {{ "V", n-5 }};
  if (n >= 4) return {{ "IV", n-4 }};
  if (n >= 1) return {{ "I", n-1 }};
  return nullopt;
}
#+END_SRC

** Unfold Example
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
int main()
{
  string r;
  unfold(to_roman, back_inserter(r), 1729);
  cout << r << '\n';
}
#+END_SRC
#+BEGIN_SRC bash
$ ./a.out
MDCCXXIX
$
#+END_SRC

** Fold and Unfold are Really the Same
Just transformations on a data structure.
#+ATTR_REVEAL: :frag appear
Which you use is a matter of convenience.
#+ATTR_REVEAL: :frag appear
We think of ~accumulate~ as working on structures and producing values, and
~unfold~ vice versa.
#+ATTR_REVEAL: :frag appear
But structures are themselves values...

#+BEGIN_NOTES
Compare ~generate~, ~generate_n~
#+END_NOTES

* Postscript: The Fruits of Algorithmic Perversions

** The Question
If you were stuck on a desert island, which algorithms would you take with you?
#+ATTR_REVEAL: :frag appear
Maybe some "building block" algorithms?
#+ATTR_REVEAL: :frag (appear)
 - ~partition~
 - ~rotate~
 - ~reverse~
#+ATTR_REVEAL: :frag appear
Maybe some others?
#+ATTR_REVEAL: :frag appear
Which algorithms are the most powerful?
#+ATTR_REVEAL: :frag appear
What if you couldn't write any loops, so you're stuck with what you have?

** The Algorithms (pre-C++17)
#+REVEAL_HTML: <div id="columns"> <div id="fiveup">
#+ATTR_REVEAL: :frag (none none none none none highlight-red none none none none none none none highlight-red none none none none none none none none none none none none none none none none none none none none fade-out none highlight-red highlight-red none none none none none none none none none none none none none highlight-red highlight-red none none none highlight-red highlight-red none highlight-red fade-out none none none none none none none none none none none none none none none none none none none none none none none fade-out none none none none highlight-red) :frag_idx (1 1 1 1 1 4 1 1 1 1 1 1 1 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 4 5 1 1 1 1 1 1 1 1 1 1 1 1 1 5 5 1 1 1 4 5 1 5 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 4)
 - ~accumulate~
 - ~adjacent_difference~
 - ~adjacent_find~
 - ~all_of~
 - ~any_of~
 - ~binary_search~
 - ~copy~
 - ~copy_backward~
 - ~copy_if~
 - ~copy_n~
 - ~count~
 - ~count_if~
 - ~equal~
 - ~equal_range~
 - ~fill~
 - ~fill_n~
 - ~find~
 - ~find_end~
 - ~find_first_of~
 - ~find_if~
 - ~find_if_not~
 - ~for_each~
 - ~generate~
 - ~generate_n~
 - ~includes~
 - ~inner_product~
 - ~inplace_merge~
 - ~iota~
 - ~is_heap~
 - ~is_heap_until~
 - ~is_partitioned~
 - ~is_permutation~
 - ~is_sorted~
 - ~is_sorted_until~
 - ~iter_swap~
 - ~lexicographical_compare~
 - ~lower_bound~
 - ~make_heap~
 - ~max~
 - ~max_element~
 - ~merge~
 - ~min~
 - ~min_element~
 - ~minmax~
 - ~minmax_element~
 - ~mismatch~
 - ~move~
 - ~move_backward~
 - ~next_permutation~
 - ~none_of~
 - ~nth_element~
 - ~partial_sort~
 - ~partial_sort_copy~
 - ~partial_sum~
 - ~partition~
 - ~partition_copy~
 - ~partition_point~
 - ~pop_heap~
 - ~prev_permutation~
 - ~push_heap~
 - ~random_shuffle~
 - ~remove~
 - ~remove_copy~
 - ~remove_copy_if~
 - ~remove_if~
 - ~replace~
 - ~replace_copy~
 - ~replace_copy_if~
 - ~replace_if~
 - ~reverse~
 - ~reverse_copy~
 - ~rotate~
 - ~rotate_copy~
 - ~search~
 - ~search_n~
 - ~set_difference~
 - ~set_intersection~
 - ~set_symmetric_difference~
 - ~set_union~
 - ~shuffle~
 - ~sort~
 - ~sort_heap~
 - ~stable_partition~
 - ~stable_sort~
 - ~swap~
 - ~swap_ranges~
 - ~transform~
 - ~unique~
 - ~unique_copy~
 - ~upper_bound~
#+REVEAL_HTML: </div></div>

#+ATTR_REVEAL: :frag appear
Of 90 total, 77 are basically "plain loops"

** Why Doesn't ~accumulate~ Work on Iterators?
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
template <class InputIt, class T, class BinaryOp>
T accumulate(InputIt first, InputIt last,
             T init, BinaryOp op)
{
  for (; first != last; ++first) {
    init = op(init, *first);
  }
  return init;
}
#+END_SRC

** Why Doesn't ~accumulate~ Work on Iterators?
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
template <class InputIt, class T, class BinaryOp>
T accumulate(InputIt first, InputIt last,
             T init, BinaryOp op)
{
  for (; first != last; ++first) {
    init = op(init, first);
  }
  return init;
}
#+END_SRC

** Hunting for Raw Loops, Redux


* Summary

** Further reading
Add ALL the Things

** Summary


#+BEGIN_NOTES
Moving beyond sums and factorials
Elementary operations: count, max, min
Better composability
Iterator category considerations
Code and data through the accumulate lens
Balanced reduction
reduce: one of the heirs of accumulate
Big data, mapreduce etc
Accumulating tree structures
Further genericization
Application to variants
Logging as an accumulation
Beyond monoids
Genericizing logging

Unfolding data structures
Accumulation as its own dual?
The fruits of algorithmic perversions
Hunting for raw loops, redux

The Most Powerful Algorithm?
It's not even in ~<algorithm>~...
APL calls it ~/~
Many languages call it ~reduce~
C++ calls it ~accumulate~ (or ~reduce~ in C++17, basically the same)

accumulate
with plus -> sum
with multiply -> factorial
count
min/max

inner_product

show generated code

more accumulations
ditch the "shall not modify elements" proviso

for_each
copy
transform
remove/replace/etc

accumulate_iter
max_element
(safe form of same using plain accumulate)

surprising forms
shuffle

reverse (with relaxed iterator category)
likewise copy_backward, move_backward

foldr with reverse iterators?

other applications
functions that return bool
functions that return int
functions that alter a data structure (insert/remove items)
turn binary functions into n-ary functions
infinite streams?

parallelization, balanced reduction
monoids
McCarthy, Knuth, EoP chapter 11

tree folds?
view "list fold" as a fold that takes two constructors
b -> (a -> b -> b) -> [a] -> b
two constructors correspond to:
1. b is how to convert [] to b
2. (a -> b -> b) is how to combine element a with existing fold result b

fold for binary tree of a has similar signature:
(a -> b) -> (b -> b -> b) -> Tree a -> a
(a -> b) is how to convert a value a at leaf into a b
(b -> b -> b) is how to combine two fold results (from subtrees)

in general any data structure can be folded given the appropriate functions to
convert from each disjoint state

we could write fold for optional (it wouldn't be very interesting; optional is
like a vector with a max of one element)

we could write a variadic fold for variant, taking a function for each type, and
using the variant's index to select the right function

heterogeneous sequences
logging
foldads

unfolds
compare generate, generate_n
possible formulations
#+END_NOTES
