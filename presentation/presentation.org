#    -*- mode: org -*-
#+OPTIONS: reveal_center:t reveal_progress:t reveal_history:t reveal_control:nil
#+OPTIONS: reveal_mathjax:t reveal_rolling_links:nil reveal_keyboard:t reveal_overview:t num:nil
#+OPTIONS: reveal_width:1200 reveal_height:900
#+OPTIONS: toc:nil <:nil timestamp:nil email:t reveal_slide_number:"c/t"
#+REVEAL_MARGIN: 0.1
#+REVEAL_MIN_SCALE: 0.5
#+REVEAL_MAX_SCALE: 2.5
#+REVEAL_TRANS: slide
#+REVEAL_THEME: solarized
#+REVEAL_HLEVEL: 2
#+REVEAL_EXTRA_CSS: ./presentation.css
#+REVEAL_ROOT: ../../presentations/reveal.js/

# (setq org-reveal-title-slide "<h1>%t</h1><h2>Exploring an Algorithmic Empire</h2><br/><h2>%a</h2><h3>%e / <a href=\"http://twitter.com/ben_deane\">@ben_deane</a></h3><h2>%d</h2>")
# (setq org-reveal-title-slide 'auto)
# see https://github.com/yjwen/org-reveal/commit/84a445ce48e996182fde6909558824e154b76985

#+TITLE: std::accumulate
#+AUTHOR: Ben Deane
#+EMAIL: bdeane@blizzard.com
#+DATE: Sometime 2016

* Part 0: The Most Powerful Algorithm in the World?

** A Long Time Ago, In a Galaxy etc...
[[./powerful.png]]

** A Long Time Ago, In a Galaxy etc...
[[./another_talk.png]]

* Part 1: Accumulatable Things

** ~std::accumulate~
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
template <class InputIt, class T, class BinaryOp>
T accumulate(InputIt first, InputIt last,
             T init, BinaryOp op)
{
  for (; first != last; ++first) {
    init = op(init, *first);
  }
  return init;
}
#+END_SRC

** Typical uses
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
vector<int> v = {1,2,3,4,5};

int sum = accumulate(v.cbegin(), v.cend(), 0, plus<>{});
cout << sum << '\n';

int product = accumulate(v.cbegin(), v.cend(), 1, multiplies<>{});
cout << product << '\n';
#+END_SRC
#+REVEAL_HTML: <br/>
#+ATTR_REVEAL: :frag appear
Of course, this is not why you're here.
What else can we accumulate?

** How about finding a min or max?
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
vector<unsigned> v = {1,2,3,4,5};

unsigned max_val = accumulate(v.cbegin(), v.cend(), 0,
    [] (unsigned a, unsigned b) { return a > b ? a : b; });
cout << max_val << '\n';
#+END_SRC

** How about finding a min or max?
Value-based ~min_element~ or ~max_element~
#+BEGIN_SRC cpp
template <typename It, typename Compare,
          typename T = typename std::iterator_traits<It>::value_type>
T min_element(It first, It last, Compare cmp)
{
  // precondition: first != last
  auto init = *first;
  return accumulate(
      ++first, last, init,
      [&] (const T& a, const T& b) {
        return cmp(b, a) ? b : a;
      });
}
#+END_SRC

** What about ~bool~ values?
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
bool results[] = {true, false, true, true, false};

bool all_true = accumulate(cbegin(results), cend(results),
                           true, logical_and<>{});
bool some_true = accumulate(cbegin(results), cend(results),
                            false, logical_or<>{});
bool none_true = !accumulate(cbegin(results), cend(results),
                             false, logical_or<>{});
#+END_SRC
#+REVEAL_HTML: <br/>
#+ATTR_REVEAL: :frag appear
Not that interesting yet...

** The signature of the function
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
Ret fun(const Type1 &a, const Type2 &b);
#+END_SRC
#+ATTR_REVEAL: :frag appear
So far, we've looked at ~Type1~ and ~Type2~ being the same.
#+ATTR_REVEAL: :frag appear
Things get more interesting when they differ.

** A more interesting ~bool~ case
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
map<int, weak_ptr<thing>> cache;

shared_ptr<thing> get_thing(int id) {
  auto sp = cache[id].lock();
  if (!sp) make_async_request(id);
  return sp;
}

void load_things(const vector<int>& ids)
{
  bool all_cached = accumulate(
    ids.cbegin(), ids.cend(), true,
    [] (bool cached, int id) {
      return get_thing(id) && cached;
    });
  if (!all_cached)
    service_async_requests();
}
#+END_SRC

** ~bool~ As the Result
We use many function results as boolean values in control flow.

 - actual ~bool~
 - pointers
 - zero-result of a comparison trichotomy
 - anywhere else we want to write ~if (x)~

#+ATTR_REVEAL: :frag appear
This means we can use ~accumulate~ to collect these function values. (Similar to
~all_of~, ~any_of~, ~none_of~, but where we don't want the short-circuiting
behavior.)

** More things...
 - joining strings
 - building requests from key-value pairs
 - merging JSON objects
 - composing textures

#+ATTR_REVEAL: :frag appear
What do all of these have in common?

** You All Remember Monoids?
A set of objects and an operation such that:
 - The operation is closed over the set
 - The operation is associative
 - There is an identity element

#+ATTR_REVEAL: :frag appear
Monoids are everywhere, and any monoid can be accumulated:
#+ATTR_REVEAL: :frag (appear)
 - addition on integers
 - concatenation on strings
 - union on sets
 - composition of textures

** Building HTTP headers: Before
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
curl_slist* curl_headers = NULL;
for (auto it = headers.begin();
     it != headers.end(); ++it)
{
  curl_headers = curl_slist_append(curl_headers,
    (format("%s: %s") % it->first % it->second).str().c_str());
}
#+END_SRC

** Building HTTP headers: After
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
curl_slist* curl_headers = accumulate(
    headers.cbegin(), headers.cend(), static_cast<curl_slist*>(nullptr),
    [] (curl_slist* h, const auto& v) {
        return curl_slist_append(h,
          (format("%s: %s") % it->first % it->second).str().c_str());
      });
#+END_SRC

** More Monoid Observations
#+ATTR_REVEAL: :frag appear
A type can be a monoid in more than one way (under more than one operation).
#+ATTR_REVEAL: :frag appear
A function that returns a monoid is a monoid.
#+ATTR_REVEAL: :frag appear
An aggregate of monoids is a monoid.

** Why not just write a loop?
Some advantages to ~accumulate~

#+ATTR_REVEAL: :frag (appear)
 - No declaration/initialization split
 - It's often easier to write a binary function
   - or unary function with monoidal output
 - Incremental computation
 - Potential for parallel computation

** What ~accumulate~ Can Do
#+ATTR_REVEAL: :frag (appear)
 - Turn binary functions into n-ary functions
 - Collect results of functions whose outputs are monoidal
 - Transform one data structure into another
 - Allow part-whole hierarchies to be treated uniformly
   - which unlocks parallel computation

* Part 2: Parallel Computation

** Diagrams 1
** Diagrams 2

** ~std::reduce~
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
template <class InputIt, class T, class BinaryOp>
T reduce(InputIt first, InputIt last,
         T init, BinaryOp op);
#+END_SRC
#+ATTR_REVEAL: :frag appear
The same as ~accumulate~, except the collection may be processed in parallel.
#+ATTR_REVEAL: :frag appear
This works because of associativity (semigroup property).
#+ATTR_REVEAL: :frag appear
We lose the type variation, but gain parallelism.

** Big Data Monoids Everywhere
#+ATTR_REVEAL: :frag (appear)
 - histograms
 - top-N calculations
 - computing averages
 - gaussian distributions
 - bloom filters
 - count-min sketch
 - hyperloglog

* Part 3: Nonlinear Structures

** ~accumulate~ Works on Linear Sequences

How would we make it work on multi-dimensional structures?
#+ATTR_REVEAL: :frag appear
Maybe we can define a linear traversal on the structure...
 - in-order, pre-order, post-order
#+ATTR_REVEAL: :frag appear
But the nodes are still homogeneous...
#+ATTR_REVEAL: :frag appear
What if it's a bit more complex? (Like say, a JSON object?)

** Recall ~std::accumulate~
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
template <class InputIt, class T, class BinaryOp>
T accumulate(InputIt first, InputIt last,
             T init, BinaryOp op);
#+END_SRC

The ~T~ here deals with an empty sequence.

The ~BinaryOp~ deals with a non-empty sequence.

** Recursive Definition of a ~vector~
We can view "sequence accumulation" as handling two cases:
 - an empty ~vector~
 - a ~vector~ consisting of an element plus another ~vector~

This is the sort of recursive definition we find in functional languages. And
it's the key to accumulating other data structures.

** ~std::accumulate~ Viewed Recursively
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
template <typename FwdIt, typename EmptyOp, typename NonEmptyOp>
auto recursive_accumulate(FwdIt first, FwdIt last,
                          EmptyOp op1, NonEmptyOp op2)
{
  if (first == last) return op1();
  return op2(*first, recursive_accumulate(first+1, last, op1, op2));
}
#+END_SRC
#+ATTR_REVEAL: :frag appear
~T~ (here ~EmptyOp~) is really a function from empty ~vector~ to ~T~
#+ATTR_REVEAL: :frag appear
~BinaryOp~ (here ~NonEmptyOp~) is really a function from (element, accumulation of ~vector~) to
~T~

** How to Accumulate a ~variant~
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
using JSONValue = variant<double,
                          string,
                          bool,
                          nullptr_t,
                          vector<JSONValue*>,
                          map<string, JSONValue*>>;
#+END_SRC
We need a function for each distinct type that can be inside the ~variant~.

** A Simple Example
Compute the "depth" of a JSON object.

** Generic variant accumulation
TODO

** Balanced reduction
TODO

* Part 4: Heterogeneous Sequences

* Part 5: The Opposite of Accumulate?

** Fold? Unfold
If ~accumulate~ is folding up a data structure to produce a value...

The opposite is "unfolding" a seed value to produce a data structure.

** How To Unfold
TODO
The signature of unfold (choice between termination conditions)
General form is to append a sequence not just a value


** Fold and Unfold are Really the Same
Just transformations on a data structure.

Which you use is a matter of convenience.

We think of ~accumulate~ as working on structures and producing values, and
~unfold~ vice versa.

But structures are themselves values.

* Postscript: The Fruits of Algorithmic Perversions

** The Question
If you were stuck on a desert island, which algorithms would you take with you?
#+ATTR_REVEAL: :frag appear
Maybe some "building block" algorithms?
#+ATTR_REVEAL: :frag (appear)
 - ~partition~
 - ~rotate~
 - ~reverse~
#+ATTR_REVEAL: :frag appear
Maybe some others?
#+ATTR_REVEAL: :frag appear
Which algorithms are the most powerful?
#+ATTR_REVEAL: :frag appear
What if you couldn't write any loops, so you're stuck with what you have?

** The Algorithms (pre-C++17)
#+REVEAL_HTML: <div id="columns"> <div id="fiveup">
#+ATTR_REVEAL: :frag (none none none none none highlight-red none none none none none none none highlight-red none none none none none none none none none none none none none none none none none none none none highlight-dimgrey none highlight-red highlight-red none none none none none none none none none none none none none highlight-red highlight-red none none none highlight-red highlight-red none highlight-red highlight-dimgrey none none none none none none none none none none none none none none none none none none none none none none none highlight-dimgrey none none none none highlight-red) :frag_idx (1 1 1 1 1 4 1 1 1 1 1 1 1 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 4 5 1 1 1 1 1 1 1 1 1 1 1 1 1 5 5 1 1 1 4 5 1 5 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 4)
 - ~accumulate~
 - ~adjacent_difference~
 - ~adjacent_find~
 - ~all_of~
 - ~any_of~
 - ~binary_search~
 - ~copy~
 - ~copy_backward~
 - ~copy_if~
 - ~copy_n~
 - ~count~
 - ~count_if~
 - ~equal~
 - ~equal_range~
 - ~fill~
 - ~fill_n~
 - ~find~
 - ~find_end~
 - ~find_first_of~
 - ~find_if~
 - ~find_if_not~
 - ~for_each~
 - ~generate~
 - ~generate_n~
 - ~includes~
 - ~inner_product~
 - ~inplace_merge~
 - ~iota~
 - ~is_heap~
 - ~is_heap_until~
 - ~is_partitioned~
 - ~is_permutation~
 - ~is_sorted~
 - ~is_sorted_until~
 - ~iter_swap~
 - ~lexicographical_compare~
 - ~lower_bound~
 - ~make_heap~
 - ~max~
 - ~max_element~
 - ~merge~
 - ~min~
 - ~min_element~
 - ~minmax~
 - ~minmax_element~
 - ~mismatch~
 - ~move~
 - ~move_backward~
 - ~next_permutation~
 - ~none_of~
 - ~nth_element~
 - ~partial_sort~
 - ~partial_sort_copy~
 - ~partial_sum~
 - ~partition~
 - ~partition_copy~
 - ~partition_point~
 - ~pop_heap~
 - ~prev_permutation~
 - ~push_heap~
 - ~random_shuffle~
 - ~remove~
 - ~remove_copy~
 - ~remove_copy_if~
 - ~remove_if~
 - ~replace~
 - ~replace_copy~
 - ~replace_copy_if~
 - ~replace_if~
 - ~reverse~
 - ~reverse_copy~
 - ~rotate~
 - ~rotate_copy~
 - ~search~
 - ~search_n~
 - ~set_difference~
 - ~set_intersection~
 - ~set_symmetric_difference~
 - ~set_union~
 - ~shuffle~
 - ~sort~
 - ~sort_heap~
 - ~stable_partition~
 - ~stable_sort~
 - ~swap~
 - ~swap_ranges~
 - ~transform~
 - ~unique~
 - ~unique_copy~
 - ~upper_bound~
#+REVEAL_HTML: </div></div>

#+ATTR_REVEAL: :frag appear
Of 90 total, 77 are basically "plain loops"

** Why Doesn't ~accumulate~ Work on Iterators?
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
template <class InputIt, class T, class BinaryOp>
T accumulate(InputIt first, InputIt last,
             T init, BinaryOp op)
{
  for (; first != last; ++first) {
    init = op(init, *first);
  }
  return init;
}
#+END_SRC

** Why Doesn't ~accumulate~ Work on Iterators?
#+REVEAL_HTML: <br/>
#+BEGIN_SRC cpp
template <class InputIt, class T, class BinaryOp>
T accumulate(InputIt first, InputIt last,
             T init, BinaryOp op)
{
  for (; first != last; ++first) {
    init = op(init, first);
  }
  return init;
}
#+END_SRC

* Summary

** Further reading
Add ALL the Things

** Summary


* Moving beyond sums and factorials
* Elementary operations: count, max, min



* Better composability
* Iterator category considerations
* Code and data through the accumulate lens
* Balanced reduction

* reduce: one of the heirs of accumulate
* Big data, mapreduce etc

* Accumulating tree structures
* Further genericization
* Application to variants

* Logging as an accumulation
* Beyond monoids
* Genericizing logging

* Unfolding data structures
* Accumulation as its own dual?

* The fruits of algorithmic perversions
* Hunting for raw loops, redux

* The Most Powerful Algorithm?
#+ATTR_REVEAL: :frag appear
It's not even in ~<algorithm>~...
#+ATTR_REVEAL: :frag appear
APL calls it ~/~
#+ATTR_REVEAL: :frag appear
Many languages call it ~reduce~
#+ATTR_REVEAL: :frag appear
C++ calls it ~accumulate~ (or ~reduce~ in C++17, basically the same)

* accumulate
with plus -> sum
with multiply -> factorial
count
min/max

inner_product

show generated code

* more accumulations
ditch the "shall not modify elements" proviso

for_each
copy
transform
remove/replace/etc

* accumulate_iter
max_element
(safe form of same using plain accumulate)

* surprising forms
shuffle

reverse (with relaxed iterator category)
likewise copy_backward, move_backward

foldr with reverse iterators?

* other applications
functions that return bool
functions that return int
functions that alter a data structure (insert/remove items)
turn binary functions into n-ary functions
infinite streams?

* parallelization, balanced reduction
monoids
McCarthy, Knuth, EoP chapter 11

* tree folds?
view "list fold" as a fold that takes two constructors
b -> (a -> b -> b) -> [a] -> b
two constructors correspond to:
1. b is how to convert [] to b
2. (a -> b -> b) is how to combine element a with existing fold result b

fold for binary tree of a has similar signature:
(a -> b) -> (b -> b -> b) -> Tree a -> a
(a -> b) is how to convert a value a at leaf into a b
(b -> b -> b) is how to combine two fold results (from subtrees)

in general any data structure can be folded given the appropriate functions to
convert from each disjoint state

we could write fold for optional (it wouldn't be very interesting; optional is
like a vector with a max of one element)

we could write a variadic fold for variant, taking a function for each type, and
using the variant's index to select the right function

* heterogeneous sequences
logging
foldads

* unfolds
compare generate, generate_n
possible formulations
